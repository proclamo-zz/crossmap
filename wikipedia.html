<html>
<head>
	<title>Wikipedia crossfilter</title>
	<style type="text/css">

		.row {
			display: table-row;
		}

		.cell {
			display: table-cell;
		}

		.map {
			width: 960px;			
		}

		.tags {
			width: 150px;
			padding: 25px;
			overflow: auto;
		}

		.keyword {
			cursor: pointer;
			color: steelblue;			
		}

		.keyword:hover {
			text-decoration: underline;
			background-color: #dcd;	
		}

		.land {
			opacity: .7;
			stroke: #888;
		}

		.point {
			fill: #f00;
			opacity: .5;			
		}

		.point:hover {
			fill: #f90;
			stroke: #000;
		}

		.selected {
			fill: yellow;
		}

		.brush .extent {
		  stroke: #fff;
		  fill-opacity: .125;
		  shape-rendering: crispEdges;
		}
	</style>
</head>
<body>

	<script src="crossfilter.v1.min.js"></script>
	<script src="d3.v3.min.js"></script>
	<script src="topojson.v1.min.js"></script>
	<script src="d3.layout.cloud.js"></script>
	<script type="text/javascript">

		d3.csv('wikipedia2.csv', function(error, wikipedia) {

			if (error) throw error;

			wikipedia.forEach(function(d, i) {
				d.index = i;
				d.lat = parseFloat(d.lat);
				d.lon = parseFloat(d.lon);
				d.keywords = d.keywords;
			});

			wikipedia = wikipedia.filter(function(el) {
					return el.hasOwnProperty("lat") && el.hasOwnProperty("lat") && 
						el.lat !== undefined && el.lon !== undefined &&
						el.lat !== null && el.lon !== null &&
						!isNaN(el.lat) && !isNaN(el.lon);
				});

			var wiki = crossfilter(wikipedia);
			var all = wiki.groupAll();
			
			var keyword = wiki.dimension(function(d) { return d.keywords; });
			
			var reduceAdd = function(p, v) {
		      /*
		      v.keywords.forEach(function(val, idx) {
		        p[val] = (p[val] || 0 ) + 1;
		      });
			*/
			p[v.keywords] = (p[v.keywords] || 0) + 1;
		      return p;
		    }

		    var reduceRemove = function(p ,v) {
		    /*	
		      v.keywords.forEach(function(val, idx) {
		        p[val] = (p[val] || 0 ) - 1;
		      });
		    */
		   	p[v.keywords] = (p[v.keywords] || 0) - 1;  
		      return p;
		    }

		    var reduceInitial = function() {
		      return {};
		    }
			

		    var keywords = function() { 
		    	return keyword.groupAll().reduce(reduceAdd, reduceRemove, reduceInitial).value();
		    }
			

		    var lat = wiki.dimension(function(d) { return d.lat; });
		    var lon = wiki.dimension(function(d) { return d.lon; });

			console.log("stop");

			// ejemplo de uso
			// lat.filterRange([-10,0])
			// keywords()
			// 
			// filterKeyword("geoclass") --> keywords() -> hay 16 para geoclass
			// lat.top(Infinity)	--> 16 elementos
			

			// mapa
			
			var width = 960,
				height = 600,
				tagsWidth = 150,
				color = d3.scale.category20b();

			var projection = d3.geo.mercator()
				.scale((width + 1) / 2 / Math.PI)
				.translate([width / 2, height / 2])
				.precision(.1);

			var path = d3.geo.path()
				.projection(projection);

			var svg = d3.select('.map').append("svg")
				.attr("width", width)
				.attr("height", height);


			var tags = d3.select(".tags").append("svg")
				.attr("width", tagsWidth)
				.attr("height", height)
				.append("g")
				.attr("transform", "translate(8,6)");	

			var x = d3.scale.linear().range([0, width]);
			//var y = d3.scale.linear().range([0, height]);

			var updateKeywords = function() {
				var extent = brush.extent(),
					coordStart = x(extent[0]),
					coordEnd = x(extent[1]),
					start = projection.invert([coordStart, null]),
					end = projection.invert([coordEnd, null]);

				console.log("extent", start, end);

				//lat.filterRange([end[0], start[0]]);
				lon.filterRange([start[0], end[0]]);

				drawKeywords();
			}	
			
			var updateMarkers = function() {
				svg.selectAll('.point')
					.classed("selected", false);
			}

			var brushend = function() {

				if (brush.empty()) {
					setBrushDefaults();
				}
			}

			var setBrushDefaults = function() {					
				brush.extent([.465625,.52]);

				d3.selectAll('.brush')
					.call(brush);
				
				updateMarkers();
				updateKeywords();
			}

			var brush = d3.svg.brush()
				.x(x)
				.on("brush", updateKeywords)
				.on("brushend", brushend);

			/*	
			var tagBrush = d3.svg.brush()
				.y(y)
				.on("brushend", updateMarkers);	
			*/
		
			svg.append("g")
				.attr("class", "brush")
				.call(brush)
				.selectAll('rect')
				.attr("height", height);


			/*	
			tags.append("g")
				.attr("class", "brush")
				.call(tagBrush)
				.selectAll('rect')
				.attr("width", tagsWidth);			
			*/

			d3.json('world-50m.json', function(error, world) {

				if (error) throw error;

				var countries = topojson.feature(world, world.objects.countries);

				svg.selectAll(".land")
					.data(countries.features)
					.enter()
						.append("path")
						.attr("class", "land")
						.attr("d", path)
						.style("fill", function(d, i) { return color(i % 10); });

				drawMarkers();		
				setBrushDefaults();
			});


			var drawMarkers = function() {

				//var markers = getMarkers();

				d3.selectAll('.point').remove();

				var data = lat.filterAll().top(Infinity);

				svg.selectAll('.point')
					.data(data)
					.enter()
						.append("svg:circle")
						.attr("cx", function(d){ return projection([d.lon,d.lat])[0]; })
						.attr("cy", function(d) { return projection([d.lon,d.lat])[1]; })
						.attr("r", 3)
						.attr("class", "point")
						.on("mouseover", function(d) {
							console.log(d);
						})	
			}


			var drawKeywords = function() {
				
				var f = [], _keywords = keywords();

				for (var i in _keywords) {
					f.push({ key: i, value: _keywords[i] });
				}
				
				var sort = crossfilter.quicksort.by(function(d) { 
					return d.value; 
				});

				sort(f, 0, f.length);
				f.reverse();
				
				d3.selectAll(".keyword").remove();
				
				var h = 20;

				tags.selectAll(".keyword")
					.data(f)
					.enter()
						.append("text")
						.attr("class", "keyword")
						.attr("transform", function(d,i) { return "translate(0," + (h * i) + ")" })
						.attr("dy", ".35em")
						.text(function(d) { return d.key + " (" + d.value + ")"; })
						.on('click', function(item, ev) {
							console.log(item, ev);

							//lat.filterAll();

							keyword.filterExact(item.key);

							selectMarkers();
						})

			}

			var getMarkers = function() {
				return keyword.top(Infinity).filter(function(el) {
					return el.hasOwnProperty("lat") && el.hasOwnProperty("lon") && 
						(+el.lat !== 0 && +el.lon !== 0);
				});
			}

			var selectMarkers = function() {

				svg.selectAll('.point')
					.classed("selected", false);

				d3.selectAll('.point').remove();	

				var markers = keyword.top(Infinity);

				svg.selectAll('.point')
					.data(markers)
					.enter()
						.append("svg:circle")
						.attr("cx", function(d){ return projection([d.lon,d.lat])[0]; })
						.attr("cy", function(d) { return projection([d.lon,d.lat])[1]; })
						.attr("r", 3)
						.attr("class", "point")
						.on("mouseover", function(d) {
							console.log(d);
						})
						.classed("selected", true);
			}

		});

	</script>

	<div class="row">
		<div class="cell map"></div>
		<div class="cell tags"></div>
	</div>
</body>
</html>